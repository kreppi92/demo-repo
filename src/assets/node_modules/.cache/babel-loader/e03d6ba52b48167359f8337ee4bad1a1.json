{"ast":null,"code":"'use strict';\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && (typeof ex === 'undefined' ? 'undefined' : _typeof(ex)) === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar parse = require('postcss-value-parser');\n\nvar parse__default = _interopDefault(parse);\n\nvar cssColorKeywords = _interopDefault(require('css-color-keywords'));\n\nvar camelizeStyleName = _interopDefault(require('camelize'));\n\nvar matchString = function matchString(node) {\n  if (node.type !== 'string') return null;\n  return node.value.replace(/\\\\([0-9a-f]{1,6})(?:\\s|$)/gi, function (match, charCode) {\n    return String.fromCharCode(parseInt(charCode, 16));\n  }).replace(/\\\\/g, '');\n};\n\nvar hexColorRe = /^(#(?:[0-9a-f]{3,4}){1,2})$/i;\nvar cssFunctionNameRe = /^(rgba?|hsla?|hwb|lab|lch|gray|color)$/;\n\nvar matchColor = function matchColor(node) {\n  if (node.type === 'word' && (hexColorRe.test(node.value) || node.value in cssColorKeywords || node.value === 'transparent')) {\n    return node.value;\n  } else if (node.type === 'function' && cssFunctionNameRe.test(node.value)) {\n    return parse.stringify(node);\n  }\n\n  return null;\n};\n\nvar noneRe = /^(none)$/i;\nvar autoRe = /^(auto)$/i;\nvar identRe = /(^-?[_a-z][_a-z0-9-]*$)/i; // Note if these are wrong, you'll need to change index.js too\n\nvar numberRe = /^([+-]?(?:\\d*\\.)?\\d+(?:[Ee][+-]?\\d+)?)$/; // Note lengthRe is sneaky: you can omit units for 0\n\nvar lengthRe = /^(0$|(?:[+-]?(?:\\d*\\.)?\\d+(?:[Ee][+-]?\\d+)?)(?=px$))/;\nvar unsupportedUnitRe = /^([+-]?(?:\\d*\\.)?\\d+(?:[Ee][+-]?\\d+)?(ch|em|ex|rem|vh|vw|vmin|vmax|cm|mm|in|pc|pt))$/;\nvar angleRe = /^([+-]?(?:\\d*\\.)?\\d+(?:[Ee][+-]?\\d+)?(?:deg|rad))$/;\nvar percentRe = /^([+-]?(?:\\d*\\.)?\\d+(?:[Ee][+-]?\\d+)?%)$/;\n\nvar noopToken = function noopToken(predicate) {\n  return function (node) {\n    return predicate(node) ? '<token>' : null;\n  };\n};\n\nvar valueForTypeToken = function valueForTypeToken(type) {\n  return function (node) {\n    return node.type === type ? node.value : null;\n  };\n};\n\nvar regExpToken = function regExpToken(regExp) {\n  var transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String;\n  return function (node) {\n    if (node.type !== 'word') return null;\n    var match = node.value.match(regExp);\n    if (match === null) return null;\n    var value = transform(match[1]);\n    return value;\n  };\n};\n\nvar tokens = {\n  SPACE: noopToken(function (node) {\n    return node.type === 'space';\n  }),\n  SLASH: noopToken(function (node) {\n    return node.type === 'div' && node.value === '/';\n  }),\n  COMMA: noopToken(function (node) {\n    return node.type === 'div' && node.value === ',';\n  }),\n  WORD: valueForTypeToken('word'),\n  NONE: regExpToken(noneRe),\n  AUTO: regExpToken(autoRe),\n  NUMBER: regExpToken(numberRe, Number),\n  LENGTH: regExpToken(lengthRe, Number),\n  UNSUPPORTED_LENGTH_UNIT: regExpToken(unsupportedUnitRe),\n  ANGLE: regExpToken(angleRe),\n  PERCENT: regExpToken(percentRe),\n  IDENT: regExpToken(identRe),\n  STRING: matchString,\n  COLOR: matchColor,\n  LINE: regExpToken(/^(none|underline|line-through)$/i)\n};\nvar NONE = tokens.NONE,\n    COLOR = tokens.COLOR,\n    LENGTH = tokens.LENGTH,\n    UNSUPPORTED_LENGTH_UNIT = tokens.UNSUPPORTED_LENGTH_UNIT,\n    SPACE = tokens.SPACE;\nvar BORDER_STYLE = regExpToken(/^(solid|dashed|dotted)$/);\nvar defaultBorderWidth = 1;\nvar defaultBorderColor = 'black';\nvar defaultBorderStyle = 'solid';\n\nvar border = function border(tokenStream) {\n  var borderWidth = void 0;\n  var borderColor = void 0;\n  var borderStyle = void 0;\n\n  if (tokenStream.matches(NONE)) {\n    tokenStream.expectEmpty();\n    return {\n      borderWidth: 0,\n      borderColor: 'black',\n      borderStyle: 'solid'\n    };\n  }\n\n  var partsParsed = 0;\n\n  while (partsParsed < 3 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE);\n\n    if (borderWidth === undefined && tokenStream.matches(LENGTH) || tokenStream.matches(UNSUPPORTED_LENGTH_UNIT)) {\n      borderWidth = tokenStream.lastValue;\n    } else if (borderColor === undefined && tokenStream.matches(COLOR)) {\n      borderColor = tokenStream.lastValue;\n    } else if (borderStyle === undefined && tokenStream.matches(BORDER_STYLE)) {\n      borderStyle = tokenStream.lastValue;\n    } else {\n      tokenStream.throw();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (borderWidth === undefined) borderWidth = defaultBorderWidth;\n  if (borderColor === undefined) borderColor = defaultBorderColor;\n  if (borderStyle === undefined) borderStyle = defaultBorderStyle;\n  return {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    borderStyle: borderStyle\n  };\n};\n\nvar LENGTH$1 = tokens.LENGTH,\n    UNSUPPORTED_LENGTH_UNIT$1 = tokens.UNSUPPORTED_LENGTH_UNIT,\n    PERCENT = tokens.PERCENT,\n    COLOR$1 = tokens.COLOR,\n    SPACE$1 = tokens.SPACE,\n    NONE$1 = tokens.NONE;\n\nvar directionFactory = function directionFactory(_ref) {\n  var _ref$types = _ref.types,\n      types = _ref$types === undefined ? [LENGTH$1, UNSUPPORTED_LENGTH_UNIT$1, PERCENT] : _ref$types,\n      _ref$directions = _ref.directions,\n      directions = _ref$directions === undefined ? ['Top', 'Right', 'Bottom', 'Left'] : _ref$directions,\n      _ref$prefix = _ref.prefix,\n      prefix = _ref$prefix === undefined ? '' : _ref$prefix,\n      _ref$suffix = _ref.suffix,\n      suffix = _ref$suffix === undefined ? '' : _ref$suffix;\n  return function (tokenStream) {\n    var _ref2;\n\n    var values = []; // borderWidth doesn't currently allow a percent value, but may do in the future\n\n    values.push(tokenStream.expect.apply(tokenStream, _toConsumableArray(types)));\n\n    while (values.length < 4 && tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE$1);\n      values.push(tokenStream.expect.apply(tokenStream, _toConsumableArray(types)));\n    }\n\n    tokenStream.expectEmpty();\n    var top = values[0],\n        _values$ = values[1],\n        right = _values$ === undefined ? top : _values$,\n        _values$2 = values[2],\n        bottom = _values$2 === undefined ? top : _values$2,\n        _values$3 = values[3],\n        left = _values$3 === undefined ? right : _values$3;\n\n    var keyFor = function keyFor(n) {\n      return '' + prefix + directions[n] + suffix;\n    };\n\n    return _ref2 = {}, _defineProperty(_ref2, keyFor(0), top), _defineProperty(_ref2, keyFor(1), right), _defineProperty(_ref2, keyFor(2), bottom), _defineProperty(_ref2, keyFor(3), left), _ref2;\n  };\n};\n\nvar parseShadowOffset = function parseShadowOffset(tokenStream) {\n  var width = tokenStream.expect(LENGTH$1);\n  var height = tokenStream.matches(SPACE$1) ? tokenStream.expect(LENGTH$1) : width;\n  tokenStream.expectEmpty();\n  return {\n    width: width,\n    height: height\n  };\n};\n\nvar parseShadow = function parseShadow(tokenStream) {\n  var offsetX = void 0;\n  var offsetY = void 0;\n  var radius = void 0;\n  var color = void 0;\n\n  if (tokenStream.matches(NONE$1)) {\n    tokenStream.expectEmpty();\n    return {\n      offset: {\n        width: 0,\n        height: 0\n      },\n      radius: 0,\n      color: 'black'\n    };\n  }\n\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE$1);\n\n    if (offsetX === undefined && tokenStream.matches(LENGTH$1, UNSUPPORTED_LENGTH_UNIT$1)) {\n      offsetX = tokenStream.lastValue;\n      tokenStream.expect(SPACE$1);\n      offsetY = tokenStream.expect(LENGTH$1, UNSUPPORTED_LENGTH_UNIT$1);\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE$1) && tokenStream.matches(LENGTH$1, UNSUPPORTED_LENGTH_UNIT$1)) {\n        radius = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (color === undefined && tokenStream.matches(COLOR$1)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream.throw();\n    }\n\n    didParseFirst = true;\n  }\n\n  if (offsetX === undefined) tokenStream.throw();\n  return {\n    offset: {\n      width: offsetX,\n      height: offsetY\n    },\n    radius: radius !== undefined ? radius : 0,\n    color: color !== undefined ? color : 'black'\n  };\n};\n\nvar boxShadow = function boxShadow(tokenStream) {\n  var _parseShadow = parseShadow(tokenStream),\n      offset = _parseShadow.offset,\n      radius = _parseShadow.radius,\n      color = _parseShadow.color;\n\n  return {\n    shadowOffset: offset,\n    shadowRadius: radius,\n    shadowColor: color,\n    shadowOpacity: 1\n  };\n};\n\nvar NONE$2 = tokens.NONE,\n    AUTO = tokens.AUTO,\n    NUMBER = tokens.NUMBER,\n    LENGTH$2 = tokens.LENGTH,\n    SPACE$2 = tokens.SPACE;\nvar defaultFlexGrow = 1;\nvar defaultFlexShrink = 1;\nvar defaultFlexBasis = 0;\n\nvar flex = function flex(tokenStream) {\n  var flexGrow = void 0;\n  var flexShrink = void 0;\n  var flexBasis = void 0;\n\n  if (tokenStream.matches(NONE$2)) {\n    tokenStream.expectEmpty();\n    return {\n      flexGrow: 0,\n      flexShrink: 0,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.saveRewindPoint();\n\n  if (tokenStream.matches(AUTO) && !tokenStream.hasTokens()) {\n    return {\n      flexGrow: 1,\n      flexShrink: 1,\n      flexBasis: 'auto'\n    };\n  }\n\n  tokenStream.rewind();\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE$2);\n\n    if (flexGrow === undefined && tokenStream.matches(NUMBER)) {\n      flexGrow = tokenStream.lastValue;\n      tokenStream.saveRewindPoint();\n\n      if (tokenStream.matches(SPACE$2) && tokenStream.matches(NUMBER)) {\n        flexShrink = tokenStream.lastValue;\n      } else {\n        tokenStream.rewind();\n      }\n    } else if (flexBasis === undefined && tokenStream.matches(LENGTH$2)) {\n      flexBasis = tokenStream.lastValue;\n    } else if (flexBasis === undefined && tokenStream.matches(AUTO)) {\n      flexBasis = 'auto';\n    } else {\n      tokenStream.throw();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexGrow === undefined) flexGrow = defaultFlexGrow;\n  if (flexShrink === undefined) flexShrink = defaultFlexShrink;\n  if (flexBasis === undefined) flexBasis = defaultFlexBasis;\n  return {\n    flexGrow: flexGrow,\n    flexShrink: flexShrink,\n    flexBasis: flexBasis\n  };\n};\n\nvar SPACE$3 = tokens.SPACE;\nvar FLEX_WRAP = regExpToken(/(nowrap|wrap|wrap-reverse)/);\nvar FLEX_DIRECTION = regExpToken(/(row|row-reverse|column|column-reverse)/);\nvar defaultFlexWrap = 'nowrap';\nvar defaultFlexDirection = 'row';\n\nvar flexFlow = function flexFlow(tokenStream) {\n  var flexWrap = void 0;\n  var flexDirection = void 0;\n  var partsParsed = 0;\n\n  while (partsParsed < 2 && tokenStream.hasTokens()) {\n    if (partsParsed !== 0) tokenStream.expect(SPACE$3);\n\n    if (flexWrap === undefined && tokenStream.matches(FLEX_WRAP)) {\n      flexWrap = tokenStream.lastValue;\n    } else if (flexDirection === undefined && tokenStream.matches(FLEX_DIRECTION)) {\n      flexDirection = tokenStream.lastValue;\n    } else {\n      tokenStream.throw();\n    }\n\n    partsParsed += 1;\n  }\n\n  tokenStream.expectEmpty();\n  if (flexWrap === undefined) flexWrap = defaultFlexWrap;\n  if (flexDirection === undefined) flexDirection = defaultFlexDirection;\n  return {\n    flexWrap: flexWrap,\n    flexDirection: flexDirection\n  };\n};\n\nvar SPACE$4 = tokens.SPACE,\n    IDENT = tokens.IDENT,\n    STRING = tokens.STRING;\n\nvar parseFontFamily = function parseFontFamily(tokenStream) {\n  var fontFamily = void 0;\n\n  if (tokenStream.matches(STRING)) {\n    fontFamily = tokenStream.lastValue;\n  } else {\n    fontFamily = tokenStream.expect(IDENT);\n\n    while (tokenStream.hasTokens()) {\n      tokenStream.expect(SPACE$4);\n      var nextIdent = tokenStream.expect(IDENT);\n      fontFamily += ' ' + nextIdent;\n    }\n  }\n\n  tokenStream.expectEmpty();\n  return {\n    fontFamily: fontFamily\n  };\n};\n\nvar SPACE$5 = tokens.SPACE,\n    LENGTH$3 = tokens.LENGTH,\n    UNSUPPORTED_LENGTH_UNIT$2 = tokens.UNSUPPORTED_LENGTH_UNIT,\n    NUMBER$1 = tokens.NUMBER,\n    SLASH = tokens.SLASH;\nvar NORMAL = regExpToken(/^(normal)$/);\nvar STYLE = regExpToken(/^(italic)$/);\nvar WEIGHT = regExpToken(/^([1-9]00|bold)$/);\nvar VARIANT = regExpToken(/^(small-caps)$/);\nvar defaultFontStyle = 'normal';\nvar defaultFontWeight = 'normal';\nvar defaultFontVariant = [];\n\nvar font = function font(tokenStream) {\n  var fontStyle = void 0;\n  var fontWeight = void 0;\n  var fontVariant = void 0; // let fontSize;\n\n  var lineHeight = void 0; // let fontFamily;\n\n  var numStyleWeightVariantMatched = 0;\n\n  while (numStyleWeightVariantMatched < 3 && tokenStream.hasTokens()) {\n    if (tokenStream.matches(NORMAL)) {\n      /* pass */\n    } else if (fontStyle === undefined && tokenStream.matches(STYLE)) {\n      fontStyle = tokenStream.lastValue;\n    } else if (fontWeight === undefined && tokenStream.matches(WEIGHT)) {\n      fontWeight = tokenStream.lastValue;\n    } else if (fontVariant === undefined && tokenStream.matches(VARIANT)) {\n      fontVariant = [tokenStream.lastValue];\n    } else {\n      break;\n    }\n\n    tokenStream.expect(SPACE$5);\n    numStyleWeightVariantMatched += 1;\n  }\n\n  var fontSize = tokenStream.expect(LENGTH$3, UNSUPPORTED_LENGTH_UNIT$2);\n\n  if (tokenStream.matches(SLASH)) {\n    if (tokenStream.matches(NUMBER$1)) {\n      lineHeight = fontSize * tokenStream.lastValue;\n    } else {\n      lineHeight = tokenStream.expect(LENGTH$3, UNSUPPORTED_LENGTH_UNIT$2);\n    }\n  }\n\n  tokenStream.expect(SPACE$5);\n\n  var _parseFontFamily = parseFontFamily(tokenStream),\n      fontFamily = _parseFontFamily.fontFamily;\n\n  if (fontStyle === undefined) fontStyle = defaultFontStyle;\n  if (fontWeight === undefined) fontWeight = defaultFontWeight;\n  if (fontVariant === undefined) fontVariant = defaultFontVariant;\n  var out = {\n    fontStyle: fontStyle,\n    fontWeight: fontWeight,\n    fontVariant: fontVariant,\n    fontSize: fontSize,\n    fontFamily: fontFamily\n  };\n  if (lineHeight !== undefined) out.lineHeight = lineHeight;\n  return out;\n};\n\nvar SPACE$6 = tokens.SPACE,\n    LINE = tokens.LINE,\n    COLOR$2 = tokens.COLOR;\nvar STYLE$1 = regExpToken(/^(solid|double|dotted|dashed)$/);\nvar defaultTextDecorationLine = 'none';\nvar defaultTextDecorationStyle = 'solid';\nvar defaultTextDecorationColor = 'black';\n\nvar textDecoration = function textDecoration(tokenStream) {\n  var line = void 0;\n  var style = void 0;\n  var color = void 0;\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE$6);\n\n    if (line === undefined && tokenStream.matches(LINE)) {\n      var lines = [tokenStream.lastValue.toLowerCase()];\n      tokenStream.saveRewindPoint();\n\n      if (lines[0] !== 'none' && tokenStream.matches(SPACE$6) && tokenStream.matches(LINE)) {\n        lines.push(tokenStream.lastValue.toLowerCase()); // Underline comes before line-through\n\n        lines.sort().reverse();\n      } else {\n        tokenStream.rewind();\n      }\n\n      line = lines.join(' ');\n    } else if (style === undefined && tokenStream.matches(STYLE$1)) {\n      style = tokenStream.lastValue;\n    } else if (color === undefined && tokenStream.matches(COLOR$2)) {\n      color = tokenStream.lastValue;\n    } else {\n      tokenStream.throw();\n    }\n\n    didParseFirst = true;\n  }\n\n  return {\n    textDecorationLine: line !== undefined ? line : defaultTextDecorationLine,\n    textDecorationColor: color !== undefined ? color : defaultTextDecorationColor,\n    textDecorationStyle: style !== undefined ? style : defaultTextDecorationStyle\n  };\n};\n\nvar SPACE$7 = tokens.SPACE,\n    LINE$1 = tokens.LINE;\n\nvar textDecorationLine = function textDecorationLine(tokenStream) {\n  var lines = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE$7);\n    lines.push(tokenStream.expect(LINE$1).toLowerCase());\n    didParseFirst = true;\n  }\n\n  lines.sort().reverse();\n  return {\n    textDecorationLine: lines.join(' ')\n  };\n};\n\nvar textShadow = function textShadow(tokenStream) {\n  var _parseShadow2 = parseShadow(tokenStream),\n      offset = _parseShadow2.offset,\n      radius = _parseShadow2.radius,\n      color = _parseShadow2.color;\n\n  return {\n    textShadowOffset: offset,\n    textShadowRadius: radius,\n    textShadowColor: color\n  };\n};\n\nvar SPACE$8 = tokens.SPACE,\n    COMMA = tokens.COMMA,\n    LENGTH$4 = tokens.LENGTH,\n    NUMBER$2 = tokens.NUMBER,\n    ANGLE = tokens.ANGLE;\n\nvar oneOfType = function oneOfType(tokenType) {\n  return function (functionStream) {\n    var value = functionStream.expect(tokenType);\n    functionStream.expectEmpty();\n    return value;\n  };\n};\n\nvar singleNumber = oneOfType(NUMBER$2);\nvar singleLength = oneOfType(LENGTH$4);\nvar singleAngle = oneOfType(ANGLE);\n\nvar xyTransformFactory = function xyTransformFactory(tokenType) {\n  return function (key, valueIfOmitted) {\n    return function (functionStream) {\n      var x = functionStream.expect(tokenType);\n      var y = void 0;\n\n      if (functionStream.hasTokens()) {\n        functionStream.expect(COMMA);\n        y = functionStream.expect(tokenType);\n      } else if (valueIfOmitted !== undefined) {\n        y = valueIfOmitted;\n      } else {\n        // Assumption, if x === y, then we can omit XY\n        // I.e. scale(5) => [{ scale: 5 }] rather than [{ scaleX: 5 }, { scaleY: 5 }]\n        return x;\n      }\n\n      functionStream.expectEmpty();\n      return [_defineProperty({}, key + 'Y', y), _defineProperty({}, key + 'X', x)];\n    };\n  };\n};\n\nvar xyNumber = xyTransformFactory(NUMBER$2);\nvar xyLength = xyTransformFactory(LENGTH$4);\nvar xyAngle = xyTransformFactory(ANGLE);\nvar partTransforms = {\n  perspective: singleNumber,\n  scale: xyNumber('scale'),\n  scaleX: singleNumber,\n  scaleY: singleNumber,\n  translate: xyLength('translate', 0),\n  translateX: singleLength,\n  translateY: singleLength,\n  rotate: singleAngle,\n  rotateX: singleAngle,\n  rotateY: singleAngle,\n  rotateZ: singleAngle,\n  skewX: singleAngle,\n  skewY: singleAngle,\n  skew: xyAngle('skew', '0deg')\n};\n\nvar transform = function transform(tokenStream) {\n  var transforms = [];\n  var didParseFirst = false;\n\n  while (tokenStream.hasTokens()) {\n    if (didParseFirst) tokenStream.expect(SPACE$8);\n    var functionStream = tokenStream.expectFunction();\n    var functionName = functionStream.functionName;\n    var transformedValues = partTransforms[functionName](functionStream);\n\n    if (!Array.isArray(transformedValues)) {\n      transformedValues = [_defineProperty({}, functionName, transformedValues)];\n    }\n\n    transforms = transformedValues.concat(transforms);\n    didParseFirst = true;\n  }\n\n  return {\n    transform: transforms\n  };\n};\n\nvar IDENT$1 = tokens.IDENT,\n    WORD = tokens.WORD,\n    COLOR$3 = tokens.COLOR,\n    LENGTH$5 = tokens.LENGTH,\n    UNSUPPORTED_LENGTH_UNIT$3 = tokens.UNSUPPORTED_LENGTH_UNIT,\n    PERCENT$1 = tokens.PERCENT,\n    AUTO$1 = tokens.AUTO;\n\nvar background = function background(tokenStream) {\n  return {\n    backgroundColor: tokenStream.expect(COLOR$3)\n  };\n};\n\nvar borderColor = directionFactory({\n  types: [COLOR$3],\n  prefix: 'border',\n  suffix: 'Color'\n});\nvar borderRadius = directionFactory({\n  directions: ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'],\n  prefix: 'border',\n  suffix: 'Radius'\n});\nvar borderWidth = directionFactory({\n  prefix: 'border',\n  suffix: 'Width'\n});\nvar margin = directionFactory({\n  types: [LENGTH$5, UNSUPPORTED_LENGTH_UNIT$3, PERCENT$1, AUTO$1],\n  prefix: 'margin'\n});\nvar padding = directionFactory({\n  prefix: 'padding'\n});\n\nvar fontVariant = function fontVariant(tokenStream) {\n  return {\n    fontVariant: [tokenStream.expect(IDENT$1)]\n  };\n};\n\nvar fontWeight = function fontWeight(tokenStream) {\n  return {\n    fontWeight: tokenStream.expect(WORD) // Also match numbers as strings\n\n  };\n};\n\nvar shadowOffset = function shadowOffset(tokenStream) {\n  return {\n    shadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar textShadowOffset = function textShadowOffset(tokenStream) {\n  return {\n    textShadowOffset: parseShadowOffset(tokenStream)\n  };\n};\n\nvar transforms = {\n  background: background,\n  border: border,\n  borderColor: borderColor,\n  borderRadius: borderRadius,\n  borderWidth: borderWidth,\n  boxShadow: boxShadow,\n  flex: flex,\n  flexFlow: flexFlow,\n  font: font,\n  fontFamily: parseFontFamily,\n  fontVariant: fontVariant,\n  fontWeight: fontWeight,\n  margin: margin,\n  padding: padding,\n  shadowOffset: shadowOffset,\n  textShadow: textShadow,\n  textShadowOffset: textShadowOffset,\n  textDecoration: textDecoration,\n  textDecorationLine: textDecorationLine,\n  transform: transform\n};\nvar SYMBOL_MATCH = 'SYMBOL_MATCH';\n\nvar TokenStream = function () {\n  function TokenStream(nodes, parent) {\n    _classCallCheck(this, TokenStream);\n\n    this.index = 0;\n    this.nodes = nodes;\n    this.functionName = parent != null ? parent.value : null;\n    this.lastValue = null;\n    this.rewindIndex = -1;\n  }\n\n  _createClass(TokenStream, [{\n    key: 'hasTokens',\n    value: function hasTokens() {\n      return this.index <= this.nodes.length - 1;\n    }\n  }, {\n    key: SYMBOL_MATCH,\n    value: function value() {\n      if (!this.hasTokens()) return null;\n      var node = this.nodes[this.index];\n\n      for (var i = 0; i < arguments.length; i += 1) {\n        var tokenDescriptor = arguments.length <= i ? undefined : arguments[i];\n        var value = tokenDescriptor(node);\n\n        if (value !== null) {\n          this.index += 1;\n          this.lastValue = value;\n          return value;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'matches',\n    value: function matches() {\n      return this[SYMBOL_MATCH].apply(this, arguments) !== null;\n    }\n  }, {\n    key: 'expect',\n    value: function expect() {\n      var value = this[SYMBOL_MATCH].apply(this, arguments);\n      return value !== null ? value : this.throw();\n    }\n  }, {\n    key: 'matchesFunction',\n    value: function matchesFunction() {\n      var node = this.nodes[this.index];\n      if (node.type !== 'function') return null;\n      var value = new TokenStream(node.nodes, node);\n      this.index += 1;\n      this.lastValue = null;\n      return value;\n    }\n  }, {\n    key: 'expectFunction',\n    value: function expectFunction() {\n      var value = this.matchesFunction();\n      return value !== null ? value : this.throw();\n    }\n  }, {\n    key: 'expectEmpty',\n    value: function expectEmpty() {\n      if (this.hasTokens()) this.throw();\n    }\n  }, {\n    key: 'throw',\n    value: function _throw() {\n      throw new Error('Unexpected token type: ' + this.nodes[this.index].type);\n    }\n  }, {\n    key: 'saveRewindPoint',\n    value: function saveRewindPoint() {\n      this.rewindIndex = this.index;\n    }\n  }, {\n    key: 'rewind',\n    value: function rewind() {\n      if (this.rewindIndex === -1) throw new Error('Internal error');\n      this.index = this.rewindIndex;\n      this.lastValue = null;\n    }\n  }]);\n\n  return TokenStream;\n}();\n/* eslint-disable no-param-reassign */\n// Note if this is wrong, you'll need to change tokenTypes.js too\n\n\nvar numberOrLengthRe = /^([+-]?(?:\\d*\\.)?\\d+(?:[Ee][+-]?\\d+)?)(?:px)?$/i;\nvar boolRe = /^true|false$/i;\nvar nullRe = /^null$/i;\nvar undefinedRe = /^undefined$/i; // Undocumented export\n\nvar transformRawValue = function transformRawValue(input) {\n  var value = input.trim();\n  var numberMatch = value.match(numberOrLengthRe);\n  if (numberMatch !== null) return Number(numberMatch[1]);\n  var boolMatch = input.match(boolRe);\n  if (boolMatch !== null) return boolMatch[0].toLowerCase() === 'true';\n  var nullMatch = input.match(nullRe);\n  if (nullMatch !== null) return null;\n  var undefinedMatch = input.match(undefinedRe);\n  if (undefinedMatch !== null) return undefined;\n  return value;\n};\n\nvar baseTransformShorthandValue = function baseTransformShorthandValue(propName, inputValue) {\n  var ast = parse__default(inputValue.trim());\n  var tokenStream = new TokenStream(ast.nodes);\n  return transforms[propName](tokenStream);\n};\n\nvar transformShorthandValue = process.env.NODE_ENV === 'production' ? baseTransformShorthandValue : function (propName, inputValue) {\n  try {\n    return baseTransformShorthandValue(propName, inputValue);\n  } catch (e) {\n    throw new Error('Failed to parse declaration \"' + propName + ': ' + inputValue + '\"');\n  }\n};\n\nvar getStylesForProperty = function getStylesForProperty(propName, inputValue, allowShorthand) {\n  var isRawValue = allowShorthand === false || !(propName in transforms);\n  var propValues = isRawValue ? _defineProperty({}, propName, transformRawValue(inputValue)) : transformShorthandValue(propName, inputValue.trim());\n  return propValues;\n};\n\nvar getPropertyName = function getPropertyName(propName) {\n  var isCustomProp = /^--\\w+/.test(propName);\n\n  if (isCustomProp) {\n    return propName;\n  }\n\n  return camelizeStyleName(propName);\n};\n\nvar index = function index(rules) {\n  var shorthandBlacklist = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return rules.reduce(function (accum, rule) {\n    var propertyName = getPropertyName(rule[0]);\n    var value = rule[1];\n    var allowShorthand = shorthandBlacklist.indexOf(propertyName) === -1;\n    return Object.assign(accum, getStylesForProperty(propertyName, value, allowShorthand));\n  }, {});\n};\n\nexports.transformRawValue = transformRawValue;\nexports.getStylesForProperty = getStylesForProperty;\nexports.getPropertyName = getPropertyName;\nexports.default = index;","map":null,"metadata":{},"sourceType":"script"}