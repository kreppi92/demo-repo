{"ast":null,"code":"'use strict';\n\nvar binary = require('node-pre-gyp');\n\nvar path = require('path');\n\nvar binding_path = binary.find(path.resolve(path.join(__dirname, './package.json')));\n\nvar bindings = require(binding_path);\n\nvar crypto = require('crypto');\n\nvar promises = require('./promises'); /// generate a salt (sync)\n/// @param {Number} [rounds] number of rounds (default 10)\n/// @return {String} salt\n\n\nmodule.exports.genSaltSync = function genSaltSync(rounds, minor) {\n  // default 10 rounds\n  if (!rounds) {\n    rounds = 10;\n  } else if (typeof rounds !== 'number') {\n    throw new Error('rounds must be a number');\n  }\n\n  if (!minor) {\n    minor = 'b';\n  } else if (minor !== 'b' && minor !== 'a') {\n    console.log(minor, typeof minor);\n    throw new Error('minor must be either \"a\" or \"b\"');\n  }\n\n  return bindings.gen_salt_sync(minor, rounds, crypto.randomBytes(16));\n}; /// generate a salt\n/// @param {Number} [rounds] number of rounds (default 10)\n/// @param {Function} cb callback(err, salt)\n\n\nmodule.exports.genSalt = function genSalt(rounds, minor, cb) {\n  var error; // if callback is first argument, then use defaults for others\n\n  if (typeof arguments[0] === 'function') {\n    // have to set callback first otherwise arguments are overriden\n    cb = arguments[0];\n    rounds = 10;\n    minor = 'b'; // callback is second argument\n  } else if (typeof arguments[1] === 'function') {\n    // have to set callback first otherwise arguments are overriden\n    cb = arguments[1];\n    minor = 'b';\n  }\n\n  if (!cb) {\n    return promises.promise(genSalt, this, [rounds, minor]);\n  } // default 10 rounds\n\n\n  if (!rounds) {\n    rounds = 10;\n  } else if (typeof rounds !== 'number') {\n    // callback error asynchronously\n    error = new Error('rounds must be a number');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (!minor) {\n    minor = 'b';\n  } else if (minor !== 'b' && minor !== 'a') {\n    error = new Error('minor must be either \"a\" or \"b\"');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  crypto.randomBytes(16, function (error, randomBytes) {\n    if (error) {\n      cb(error);\n      return;\n    }\n\n    bindings.gen_salt(minor, rounds, randomBytes, cb);\n  });\n}; /// hash data using a salt\n/// @param {String} data the data to encrypt\n/// @param {String} salt the salt to use when hashing\n/// @return {String} hash\n\n\nmodule.exports.hashSync = function hashSync(data, salt) {\n  if (data == null || salt == null) {\n    throw new Error('data and salt arguments required');\n  }\n\n  if (typeof data !== 'string' || typeof salt !== 'string' && typeof salt !== 'number') {\n    throw new Error('data must be a string and salt must either be a salt string or a number of rounds');\n  }\n\n  if (typeof salt === 'number') {\n    salt = module.exports.genSaltSync(salt);\n  }\n\n  return bindings.encrypt_sync(data, salt);\n}; /// hash data using a salt\n/// @param {String} data the data to encrypt\n/// @param {String} salt the salt to use when hashing\n/// @param {Function} cb callback(err, hash)\n\n\nmodule.exports.hash = function hash(data, salt, cb) {\n  var error;\n\n  if (typeof data === 'function') {\n    error = new Error('data must be a string and salt must either be a salt string or a number of rounds');\n    return process.nextTick(function () {\n      data(error);\n    });\n  }\n\n  if (typeof salt === 'function') {\n    error = new Error('data must be a string and salt must either be a salt string or a number of rounds');\n    return process.nextTick(function () {\n      salt(error);\n    });\n  } // cb exists but is not a function\n  // return a rejecting promise\n\n\n  if (cb && typeof cb !== 'function') {\n    return promises.reject(new Error('cb must be a function or null to return a Promise'));\n  }\n\n  if (!cb) {\n    return promises.promise(hash, this, [data, salt]);\n  }\n\n  if (data == null || salt == null) {\n    error = new Error('data and salt arguments required');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (typeof data !== 'string' || typeof salt !== 'string' && typeof salt !== 'number') {\n    error = new Error('data must be a string and salt must either be a salt string or a number of rounds');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (typeof salt === 'number') {\n    return module.exports.genSalt(salt, function (err, salt) {\n      return bindings.encrypt(data, salt, cb);\n    });\n  }\n\n  return bindings.encrypt(data, salt, cb);\n}; /// compare raw data to hash\n/// @param {String} data the data to hash and compare\n/// @param {String} hash expected hash\n/// @return {bool} true if hashed data matches hash\n\n\nmodule.exports.compareSync = function compareSync(data, hash) {\n  if (data == null || hash == null) {\n    throw new Error('data and hash arguments required');\n  }\n\n  if (typeof data !== 'string' || typeof hash !== 'string') {\n    throw new Error('data and hash must be strings');\n  }\n\n  return bindings.compare_sync(data, hash);\n}; /// compare raw data to hash\n/// @param {String} data the data to hash and compare\n/// @param {String} hash expected hash\n/// @param {Function} cb callback(err, matched) - matched is true if hashed data matches hash\n\n\nmodule.exports.compare = function compare(data, hash, cb) {\n  var error;\n\n  if (typeof data === 'function') {\n    error = new Error('data and hash arguments required');\n    return process.nextTick(function () {\n      data(error);\n    });\n  }\n\n  if (typeof hash === 'function') {\n    error = new Error('data and hash arguments required');\n    return process.nextTick(function () {\n      hash(error);\n    });\n  } // cb exists but is not a function\n  // return a rejecting promise\n\n\n  if (cb && typeof cb !== 'function') {\n    return promises.reject(new Error('cb must be a function or null to return a Promise'));\n  }\n\n  if (!cb) {\n    return promises.promise(compare, this, [data, hash]);\n  }\n\n  if (data == null || hash == null) {\n    error = new Error('data and hash arguments required');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  if (typeof data !== 'string' || typeof hash !== 'string') {\n    error = new Error('data and hash must be strings');\n    return process.nextTick(function () {\n      cb(error);\n    });\n  }\n\n  return bindings.compare(data, hash, cb);\n}; /// @param {String} hash extract rounds from this hash\n/// @return {Number} the number of rounds used to encrypt a given hash\n\n\nmodule.exports.getRounds = function getRounds(hash) {\n  if (hash == null) {\n    throw new Error('hash argument required');\n  }\n\n  if (typeof hash !== 'string') {\n    throw new Error('hash must be a string');\n  }\n\n  return bindings.get_rounds(hash);\n};","map":null,"metadata":{},"sourceType":"script"}