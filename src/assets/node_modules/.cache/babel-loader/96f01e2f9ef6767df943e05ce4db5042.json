{"ast":null,"code":"'use strict';\n\nvar Promise = global.Promise; /// encapsulate a method with a node-style callback in a Promise\n/// @param {object} 'this' of the encapsulated function\n/// @param {function} function to be encapsulated\n/// @param {Array-like} args to be passed to the called function\n/// @return {Promise} a Promise encapsulating the function\n\nmodule.exports.promise = function (fn, context, args) {\n  if (!Array.isArray(args)) {\n    args = Array.prototype.slice.call(args);\n  }\n\n  if (typeof fn !== 'function') {\n    return Promise.reject(new Error('fn must be a function'));\n  }\n\n  return new Promise(function (resolve, reject) {\n    args.push(function (err, data) {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(data);\n      }\n    });\n    fn.apply(context, args);\n  });\n}; /// @param {err} the error to be thrown\n\n\nmodule.exports.reject = function (err) {\n  return Promise.reject(err);\n}; /// changes the promise implementation that bcrypt uses\n/// @param {Promise} the implementation to use\n\n\nmodule.exports.use = function (promise) {\n  Promise = promise;\n};","map":null,"metadata":{},"sourceType":"script"}